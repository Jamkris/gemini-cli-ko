# Gemini CLI 예제

Gemini CLI를 어디서부터 시작해야 할지 모르시겠나요? 이 문서에서는 다양한 작업에 Gemini CLI를 사용하는 방법에 대한 예제를 다룹니다.

**참고:** 결과는 잠재적인 사용 사례를 보여주기 위한 예시입니다. 실제 결과는 다를 수 있습니다.

## 내용을 기반으로 사진 이름 바꾸기

시나리오: 다음 파일이 포함된 폴더가 있습니다.

```bash
photos/photo1.png
photos/photo2.png
photos/photo3.png
```

Gemini에 다음 프롬프트를 입력하세요.

```cli
"photos" 디렉터리에 있는 사진의 이름을 내용을 기반으로 변경해 주세요.
```

결과: Gemini가 파일 이름 변경 권한을 요청합니다.

**Allow once**를 선택하면 파일 이름이 변경됩니다.

```bash
photos/yellow_flowers.png
photos/antique_dresser.png
photos/green_android_robot.png
```

## 코드를 읽어 리포지토리 설명하기

시나리오: 단순히 README만 보는 것이 아니라 코드를 검사하여 인기 있는 오픈 소스 유틸리티가 어떻게 작동하는지 이해하고 싶습니다.

Gemini CLI에 다음 프롬프트를 입력하세요.

```cli
https://github.com/chalk/chalk에서 'chalk' 리포지토리를 복제하고, 주요 소스 파일을 읽고, 어떻게 작동하는지 설명해 주세요.
```

결과: Gemini는 요청에 응답하기 위해 일련의 작업을 수행합니다.

1.  먼저 `git clone`을 실행하여 리포지토리를 다운로드할 수 있는 권한을 요청합니다.
2.  다음으로 중요한 소스 파일을 찾고 이를 읽을 수 있는 권한을 요청합니다.
3.  마지막으로 코드를 분석한 후 요약을 제공합니다.

Gemini CLI는 실제 소스 코드를 기반으로 한 설명을 반환합니다.

```markdown
`chalk` 라이브러리는 색상으로 터미널 출력을 스타일링하기 위한 인기 있는 npm 패키지입니다. 소스 코드를 분석한 결과, 작동 방식은 다음과 같습니다.

- **핵심 기능:** 기본 파일은 체인 가능한 API를 설정합니다. 각 색상이나 수정자(예: `bold` 또는 `italic`)는 해당 ANSI 이스케이프 코드를 내부 스택에 추가하는 getter입니다.

- **체인 가능한 API:** `chalk.red.bold('Hello')`를 호출하면 getter에 액세스하는 것입니다. `red` getter는 빨간색 코드를 추가하고 `bold` getter는 굵게 코드를 추가합니다.

- **출력 생성:** 체인이 문자열로 처리될 때(예: `console.log`에서) 최종 `toString()` 메서드가 호출됩니다. 이 메서드는 저장된 모든 ANSI 코드를 결합하고 입력 문자열('Hello')을 감싸고 끝에 재설정 코드를 추가합니다. 이렇게 하면 터미널이 렌더링할 수 있는 최종 스타일 문자열이 생성됩니다.
```

## 두 개의 스프레드시트를 하나의 스프레드시트로 결합하기

시나리오: `Revenue - 2023.csv`와 `Revenue - 2024.csv`라는 두 개의 .csv 파일이 있습니다. 각 파일에는 다음과 같은 월별 수익 수치가 포함되어 있습니다.

```csv
January,0
February,0
March,0
April,900
May,1000
June,1000
July,1200
August,1800
September,2000
October,2400
November,3400
December,2100
```

이 두 개의 .csv 파일을 하나의 .csv 파일로 결합하고 싶습니다.

Gemini CLI에 다음 프롬프트를 입력하세요.

```cli
두 개의 .csv 파일을 하나의 .csv 파일로 결합하고 각 연도를 다른 열로 만드세요.
```

결과: Gemini CLI가 각 파일을 읽은 다음 새 파일을 쓸 수 있는 권한을 요청합니다. 권한을 제공하면 Gemini CLI가 다음 .csv를 제공합니다.

```csv
Month,2023,2024
January,0,1000
February,0,1200
March,0,2400
April,900,500
May,1000,800
June,1000,900
July,1200,1000
August,1800,400
September,2000,2000
October,2400,3400
November,3400,1800
December,2100,9000
```

## 단위 테스트 실행

시나리오: 간단한 로그인 페이지를 작성했습니다. 로그인 페이지에 코드 커버리지가 있는지 확인하기 위해 단위 테스트를 작성하려고 합니다.

Gemini CLI에 다음 프롬프트를 입력하세요.

```cli
Login.js에 대한 단위 테스트를 작성해 주세요.
```

결과: Gemini CLI가 새 파일을 쓸 수 있는 권한을 요청하고 로그인 페이지에 대한 테스트를 만듭니다.

```javascript
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import Login from './Login';

// Mock the API call for login
jest.mock('./api', () => ({
  login: jest.fn(),
}));

describe('Login component', () => {
  it('renders the login form correctly', () => {
    const { getByLabelText, getByText } = render(<Login />);

    expect(getByLabelText('Username')).toBeInTheDocument();
    expect(getByLabelText('Password')).toBeInTheDocument();
    expect(getByText('Login')).toBeInTheDocument();
  });

  it('shows an error message with invalid credentials', async () => {
    const { getByLabelText, getByText, findByText } = render(<Login />);
    const usernameInput = getByLabelText('Username');
    const passwordInput = getByLabelText('Password');
    const loginButton = getByText('Login');

    // Mock the API to return an error
    require('./api').login.mockRejectedValue(new Error('Invalid credentials'));

    fireEvent.change(usernameInput, { target: { value: 'testuser' } });
    fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } });
    fireEvent.click(loginButton);

    const errorMessage = await findByText('Invalid credentials');
    expect(errorMessage).toBeInTheDocument();
  });

  it('logs in successfully with valid credentials', async () => {
    const onLoginSuccess = jest.fn();
    const { getByLabelText, getByText } = render(
      <Login onLoginSuccess={onLoginSuccess} />,
    );
    const usernameInput = getByLabelText('Username');
    const passwordInput = getByLabelText('Password');
    const loginButton = getByText('Login');

    // Mock the API to return a success message
    require('./api').login.mockResolvedValue({ success: true });

    fireEvent.change(usernameInput, { target: { value: 'testuser' } });
    fireEvent.change(passwordInput, { target: { value: 'correctpassword' } });
    fireEvent.click(loginButton);

    await waitFor(() => {
      expect(onLoginSuccess).toHaveBeenCalled();
    });
  });

  it('disables the submit button while submitting', async () => {
    const { getByLabelText, getByText } = render(<Login />);
    const usernameInput = getByLabelText('Username');
    const passwordInput = getByLabelText('Password');
    const loginButton = getByText('Login');

    // Mock the API to have a delay
    require('./api').login.mockImplementation(
      () =>
        new Promise((resolve) =>
          setTimeout(() => resolve({ success: true }), 1000),
        ),
    );

    fireEvent.change(usernameInput, { target: { value: 'testuser' } });
    fireEvent.change(passwordInput, { target: { value: 'correctpassword' } });
    fireEvent.click(loginButton);

    expect(loginButton).toBeDisabled();

    await waitFor(() => {
      expect(loginButton).not.toBeDisabled();
    });
  });
});
```
