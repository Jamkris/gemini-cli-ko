# Gemini CLIìš© í›… ì‘ì„±í•˜ê¸° (Writing hooks for Gemini CLI)

ì´ ê°€ì´ë“œëŠ” ê°„ë‹¨í•œ ë¡œê¹… í›…ë¶€í„° í¬ê´„ì ì¸ ì›Œí¬í”Œë¡œìš° ì§€ì›ê¹Œì§€ Gemini CLIìš© í›…ì„ ë§Œë“œëŠ” ê³¼ì •ì„ ì•ˆë‚´í•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´ (Prerequisites)

ì‹œì‘í•˜ê¸° ì „ì— ë‹¤ìŒ ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”.

- Gemini CLI ì„¤ì¹˜ ë° êµ¬ì„± ì™„ë£Œ
- ì‰˜ ìŠ¤í¬ë¦½íŒ… ë˜ëŠ” JavaScript/Node.jsì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì´í•´
- í›… ì…ë ¥/ì¶œë ¥ì„ ìœ„í•œ JSONì— ëŒ€í•œ ì¹œìˆ™í•¨

## ë¹ ë¥¸ ì‹œì‘ (Quick start)

ê¸°ë³¸ì ì¸ ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ ëª¨ë“  ë„êµ¬ ì‹¤í–‰ì„ ë¡œê¹…í•˜ëŠ” ê°„ë‹¨í•œ í›…ì„ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤.

**ì¤‘ìš”í•œ ê·œì¹™:** ë¡œê·¸ëŠ” í•­ìƒ `stderr`ì— ì‘ì„±í•˜ì„¸ìš”. ìµœì¢… JSONë§Œ `stdout`ì— ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.

### 1ë‹¨ê³„: í›… ìŠ¤í¬ë¦½íŠ¸ ë§Œë“¤ê¸°

í›…ì„ ìœ„í•œ ë””ë ‰í„°ë¦¬ì™€ ê°„ë‹¨í•œ ë¡œê¹… ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë§Œë“­ë‹ˆë‹¤.

> **ì°¸ê³ **:
>
> ì´ ì˜ˆì œëŠ” `jq`ë¥¼ ì‚¬ìš©í•˜ì—¬ JSONì„ íŒŒì‹±í•©ë‹ˆë‹¤. `jq`ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ Node.jsë‚˜ Pythonì„ ì‚¬ìš©í•˜ì—¬ ìœ ì‚¬í•œ ë¡œì§ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```bash
mkdir -p .gemini/hooks
cat > .gemini/hooks/log-tools.sh << 'EOF'
#!/usr/bin/env bash
# Read hook input from stdin
input=$(cat)

# Extract tool name (requires jq)
tool_name=$(echo "$input" | jq -r '.tool_name')

# Log to stderr (visible in terminal if hook fails, or captured in logs)
echo "Logging tool: $tool_name" >&2

# Log to file
echo "[$(date)] Tool executed: $tool_name" >> .gemini/tool-log.txt

# Return success (exit 0) with empty JSON
echo "{}"
exit 0
EOF

chmod +x .gemini/hooks/log-tools.sh
```

## ì¢…ë£Œ ì½”ë“œ ì „ëµ (Exit Code Strategies)

Gemini CLIì—ì„œ ì‘ì—…ì„ ì œì–´í•˜ê±°ë‚˜ ì°¨ë‹¨í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.

| ì „ëµ                | ì¢…ë£Œ ì½”ë“œ | êµ¬í˜„                                                                   | ìš©ë„                                                  |
| :------------------ | :-------- | :--------------------------------------------------------------------- | :---------------------------------------------------- |
| **êµ¬ì¡°ì  (ê´€ìš©ì )** | `0`       | `{"decision": "deny", "reason": "..."}`ì™€ ê°™ì€ JSON ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. | í”„ë¡œë•ì…˜ í›…, ì‚¬ìš©ì ì •ì˜ í”¼ë“œë°±, ë³µì¡í•œ ë¡œì§.         |
| **ë¹„ìƒ ì •ì§€**       | `2`       | ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ `stderr`ì— ì¶œë ¥í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.                          | ê°„ë‹¨í•œ ë³´ì•ˆ ê²Œì´íŠ¸, ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜, ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘. |

## ì‹¤ìš©ì ì¸ ì˜ˆì œ (Practical examples)

### ë³´ì•ˆ: ì»¤ë°‹ ì‹œ ë¹„ë°€ ì •ë³´ ì°¨ë‹¨ (Security: Block secrets in commits)

API í‚¤ë‚˜ ë¹„ë°€ë²ˆí˜¸ê°€ í¬í•¨ëœ íŒŒì¼ì„ ì»¤ë°‹í•˜ì§€ ëª»í•˜ë„ë¡ ë°©ì§€í•©ë‹ˆë‹¤. ì—ì´ì „íŠ¸ì—ê²Œ êµ¬ì¡°í™”ëœ ê±°ë¶€ ë©”ì‹œì§€ë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ **ì¢…ë£Œ ì½”ë“œ 0**ì„ ì‚¬ìš©í•œë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì„¸ìš”.

**`.gemini/hooks/block-secrets.sh`:**

```bash
#!/usr/bin/env bash
input=$(cat)

# Extract content being written
content=$(echo "$input" | jq -r '.tool_input.content // .tool_input.new_string // ""')

# Check for secrets
if echo "$content" | grep -qE 'api[_-]?key|password|secret'; then
  # Log to stderr
  echo "Blocked potential secret" >&2

  # Return structured denial to stdout
  cat <<EOF
{
  "decision": "deny",
  "reason": "Security Policy: Potential secret detected in content.",
  "systemMessage": "ğŸ”’ Security scanner blocked operation"
}
EOF
  exit 0
fi

# Allow
echo '{"decision": "allow"}'
exit 0
```

### ë™ì  ì»¨í…ìŠ¤íŠ¸ ì£¼ì… (Git ê¸°ë¡) (Dynamic context injection)

ê° ì—ì´ì „íŠ¸ ìƒí˜¸ ì‘ìš© ì „ì— ê´€ë ¨ í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

**`.gemini/hooks/inject-context.sh`:**

```bash
#!/usr/bin/env bash

# Get recent git commits for context
context=$(git log -5 --oneline 2>/dev/null || echo "No git history")

# Return as JSON
cat <<EOF
{
  "hookSpecificOutput": {
    "hookEventName": "BeforeAgent",
    "additionalContext": "Recent commits:\n$context"
  }
}
EOF
```

### RAG ê¸°ë°˜ ë„êµ¬ í•„í„°ë§ (BeforeToolSelection)

`BeforeToolSelection`ì„ ì‚¬ìš©í•˜ì—¬ ì§€ëŠ¥ì ìœ¼ë¡œ ë„êµ¬ ê³µê°„ì„ ì¤„ì´ì„¸ìš”. ì´ ì˜ˆì œëŠ” Node.js ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ìì˜ í”„ë¡¬í”„íŠ¸ë¥¼ í™•ì¸í•˜ê³  ê´€ë ¨ ë„êµ¬ë§Œ í—ˆìš©í•©ë‹ˆë‹¤.

**`.gemini/hooks/filter-tools.js`:**

```javascript
#!/usr/bin/env node
const fs = require('fs');

async function main() {
  const input = JSON.parse(fs.readFileSync(0, 'utf-8'));
  const { llm_request } = input;

  // Decoupled API: Access messages from llm_request
  const messages = llm_request.messages || [];
  const lastUserMessage = messages
    .slice()
    .reverse()
    .find((m) => m.role === 'user');

  if (!lastUserMessage) {
    console.log(JSON.stringify({})); // Do nothing
    return;
  }

  const text = lastUserMessage.content;
  const allowed = ['write_todos']; // Always allow memory

  // Simple keyword matching
  if (text.includes('read') || text.includes('check')) {
    allowed.push('read_file', 'list_directory');
  }
  if (text.includes('test')) {
    allowed.push('run_shell_command');
  }

  // If we found specific intent, filter tools. Otherwise allow all.
  if (allowed.length > 1) {
    console.log(
      JSON.stringify({
        hookSpecificOutput: {
          hookEventName: 'BeforeToolSelection',
          toolConfig: {
            mode: 'ANY', // Force usage of one of these tools (or AUTO)
            allowedFunctionNames: allowed,
          },
        },
      }),
    );
  } else {
    console.log(JSON.stringify({}));
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
```

**`.gemini/settings.json`:**

```json
{
  "hooks": {
    "BeforeToolSelection": [
      {
        "matcher": "*",
        "hooks": [
          {
            "name": "intent-filter",
            "type": "command",
            "command": "node .gemini/hooks/filter-tools.js"
          }
        ]
      }
    ]
  }
}
```

> **íŒ (TIP)**
>
> **í†µí•© ì§‘ê³„ ì „ëµ (Union Aggregation Strategy)**: `BeforeToolSelection`ì€ ì¼ì¹˜í•˜ëŠ” ëª¨ë“  í›…ì˜ ê²°ê³¼ë¥¼ ê²°í•©í•œë‹¤ëŠ” ì ì—ì„œ ë…íŠ¹í•©ë‹ˆë‹¤. ì—¬ëŸ¬ í•„í„°ë§ í›…ì´ ìˆëŠ” ê²½ìš° ì—ì´ì „íŠ¸ëŠ” í—ˆìš©ëœ ëª¨ë“  ë„êµ¬ì˜ **í•©ì§‘í•©(union)**ì„ ë°›ê²Œ ë©ë‹ˆë‹¤. `mode: "NONE"`ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ë§Œ ë‹¤ë¥¸ í›…ì„ ë¬´ì‹œí•˜ê³  ëª¨ë“  ë„êµ¬ë¥¼ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤.

## ì „ì²´ ì˜ˆì œ: ìŠ¤ë§ˆíŠ¸ ê°œë°œ ì›Œí¬í”Œë¡œìš° ì–´ì‹œìŠ¤í„´íŠ¸ (Complete example: Smart Development Workflow Assistant)

ì´ í¬ê´„ì ì¸ ì˜ˆì œëŠ” ëª¨ë“  í›… ì´ë²¤íŠ¸ê°€ í•¨ê»˜ ì‘ë™í•˜ëŠ” ë°©ì‹ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ë©”ëª¨ë¦¬ë¥¼ ìœ ì§€í•˜ê³ , ë„êµ¬ë¥¼ í•„í„°ë§í•˜ê³ , ë³´ì•ˆì„ í™•ì¸í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ê²ƒì…ë‹ˆë‹¤.

### ì•„í‚¤í…ì²˜ (Architecture)

1. **SessionStart**: í”„ë¡œì íŠ¸ ë©”ëª¨ë¦¬ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
2. **BeforeAgent**: ë©”ëª¨ë¦¬ë¥¼ ì»¨í…ìŠ¤íŠ¸ì— ì£¼ì…í•©ë‹ˆë‹¤.
3. **BeforeToolSelection**: ì˜ë„ì— ë”°ë¼ ë„êµ¬ë¥¼ í•„í„°ë§í•©ë‹ˆë‹¤.
4. **BeforeTool**: ë¹„ë°€ ì •ë³´ë¥¼ ê²€ì‚¬í•©ë‹ˆë‹¤.
5. **AfterModel**: ìƒí˜¸ ì‘ìš©ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
6. **AfterAgent**: ìµœì¢… ì‘ë‹µ í’ˆì§ˆì„ ê²€ì¦í•©ë‹ˆë‹¤ (ì¬ì‹œë„).
7. **SessionEnd**: ë©”ëª¨ë¦¬ë¥¼ í†µí•©í•©ë‹ˆë‹¤.

### êµ¬ì„± (`.gemini/settings.json`)

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "name": "init",
            "type": "command",
            "command": "node .gemini/hooks/init.js"
          }
        ]
      }
    ],
    "BeforeAgent": [
      {
        "matcher": "*",
        "hooks": [
          {
            "name": "memory",
            "type": "command",
            "command": "node .gemini/hooks/inject-memories.js"
          }
        ]
      }
    ],
    "BeforeToolSelection": [
      {
        "matcher": "*",
        "hooks": [
          {
            "name": "filter",
            "type": "command",
            "command": "node .gemini/hooks/rag-filter.js"
          }
        ]
      }
    ],
    "BeforeTool": [
      {
        "matcher": "write_file",
        "hooks": [
          {
            "name": "security",
            "type": "command",
            "command": "node .gemini/hooks/security.js"
          }
        ]
      }
    ],
    "AfterModel": [
      {
        "matcher": "*",
        "hooks": [
          {
            "name": "record",
            "type": "command",
            "command": "node .gemini/hooks/record.js"
          }
        ]
      }
    ],
    "AfterAgent": [
      {
        "matcher": "*",
        "hooks": [
          {
            "name": "validate",
            "type": "command",
            "command": "node .gemini/hooks/validate.js"
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "matcher": "exit",
        "hooks": [
          {
            "name": "save",
            "type": "command",
            "command": "node .gemini/hooks/consolidate.js"
          }
        ]
      }
    ]
  }
}
```

### í›… ìŠ¤í¬ë¦½íŠ¸ (Hook Scripts)

> **ì°¸ê³ **: ê°„ê²°í•¨ì„ ìœ„í•´ ì´ ìŠ¤í¬ë¦½íŠ¸ë“¤ì€ ë¡œê¹…ì— `console.error`ë¥¼ ì‚¬ìš©í•˜ê³  JSON ì¶œë ¥ì— í‘œì¤€ `console.log`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

#### 1. ì´ˆê¸°í™” (`init.js`)

```javascript
#!/usr/bin/env node
// Initialize DB or resources
console.error('Initializing assistant...');

// Output to user
console.log(
  JSON.stringify({
    systemMessage: 'ğŸ§  Smart Assistant Loaded',
  }),
);
```

#### 2. ë©”ëª¨ë¦¬ ì£¼ì… (`inject-memories.js`)

```javascript
#!/usr/bin/env node
const fs = require('fs');

async function main() {
  const input = JSON.parse(fs.readFileSync(0, 'utf-8'));
  // Assume we fetch memories from a DB here
  const memories = '- [Memory] Always use TypeScript for this project.';

  console.log(
    JSON.stringify({
      hookSpecificOutput: {
        hookEventName: 'BeforeAgent',
        additionalContext: `\n## Relevant Memories\n${memories}`,
      },
    }),
  );
}
main();
```

#### 3. ë³´ì•ˆ ê²€ì‚¬ (`security.js`)

```javascript
#!/usr/bin/env node
const fs = require('fs');
const input = JSON.parse(fs.readFileSync(0));
const content = input.tool_input.content || '';

if (content.includes('SECRET_KEY')) {
  console.log(
    JSON.stringify({
      decision: 'deny',
      reason: 'Found SECRET_KEY in content',
      systemMessage: 'ğŸš¨ Blocked sensitive commit',
    }),
  );
  process.exit(0);
}

console.log(JSON.stringify({ decision: 'allow' }));
```

#### 4. ìƒí˜¸ ì‘ìš© ê¸°ë¡ (`record.js`)

```javascript
#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const input = JSON.parse(fs.readFileSync(0));
const { llm_request, llm_response } = input;
const logFile = path.join(
  process.env.GEMINI_PROJECT_DIR,
  '.gemini/memory/session.jsonl',
);

fs.appendFileSync(
  logFile,
  JSON.stringify({
    request: llm_request,
    response: llm_response,
    timestamp: new Date().toISOString(),
  }) + '\n',
);

console.log(JSON.stringify({}));
```

#### 5. ì‘ë‹µ ê²€ì¦ (`validate.js`)

```javascript
#!/usr/bin/env node
const fs = require('fs');
const input = JSON.parse(fs.readFileSync(0));
const response = input.prompt_response;

// Example: Check if the agent forgot to include a summary
if (!response.includes('Summary:')) {
  console.log(
    JSON.stringify({
      decision: 'block', // Triggers an automatic retry turn
      reason: 'Your response is missing a Summary section. Please add one.',
      systemMessage: 'ğŸ”„ Requesting missing summary...',
    }),
  );
  process.exit(0);
}

console.log(JSON.stringify({ decision: 'allow' }));
```

#### 6. ë©”ëª¨ë¦¬ í†µí•© (`consolidate.js`)

```javascript
#!/usr/bin/env node
// Logic to save final session state
console.error('Consolidating memories for session end...');
```

## í™•ì¥ í”„ë¡œê·¸ë¨ìœ¼ë¡œ íŒ¨í‚¤ì§•í•˜ê¸° (Packaging as an extension)

í”„ë¡œì íŠ¸ ìˆ˜ì¤€ì˜ í›…ì€ íŠ¹ì • ë¦¬í¬ì§€í† ë¦¬ì— ì í•©í•˜ì§€ë§Œ, í›…ì„ [Gemini CLI í™•ì¥ í”„ë¡œê·¸ë¨](https://www.google.com/search?q=../extensions/index.md)ìœ¼ë¡œ íŒ¨í‚¤ì§•í•˜ì—¬ ì—¬ëŸ¬ í”„ë¡œì íŠ¸ì—ì„œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë²„ì „ ê´€ë¦¬, ì‰¬ìš´ ë°°í¬ ë° ì¤‘ì•™ ì§‘ì¤‘ì‹ ê´€ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
